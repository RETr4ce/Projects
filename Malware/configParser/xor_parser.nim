#[
  Execise for parsing xor'ed strings stored in a dll.
]#

import std/[streams, strformat]

const 
  key = "KingOfThePirates!"
  address = {
  # File offset: Buffer
    0x6E920: 1956,
    0x6E3B8: 1223,
    0x6E220: 21,
    0x6E330: 88,
    0x6FA30: 203,
    0x6FAFC: 36,
    0x6F9CC: 58,
    0x6FA08: 38,
    0x6E1EC: 50,
    0x6F958: 57,
    0x6E38C: 35,
    0x6E250: 162,
    0x6E3B0: 4,
    0x6FD8C: 6,
    0x6F928: 3,
    0x6E24C: 2,
    0x6FD3C: 2,
    0x6E8D8: 5,
    0x6F924: 2,
    0x6E2F4: 4,
    0x6FD64: 4,
    0x6F920: 3,
    0x6FD5C: 5,
    0x6FD6C: 30,
    0x6FD94: 30,
    0x6F994: 4,
    0x6FB68: 467,
    0x6E8E0: 50,
    0x6E2FC: 51,
    0x6F92C: 41,
    0x6E89C: 59,
    0x6E880: 26,
    0x6FDB4: 27,
    0x6E238: 16,
    0x6FB34: 48,
    0x6FB24: 15,
    0x6F99C: 45,
    0x6E098: 338,
    0x6FD40: 26,
    0x6E914: 9
  }

var 
  strm = newFileStream("malicious.dll", fmRead)
  count: int = 0

proc deobfuscation(a: openArray[byte], buffLen:int): string =

  var message: string  

  for i in 0..<buffLen:
    message &= chr(a[i] xor byte(key[i mod key.len]))
  return message

for i in 0..<address.len:
  count.inc
  var buff: array[1956, byte]   # With nim you've to evaluate at compile time.
  strm.setPosition address[i][0]
  discard strm.readData(buff[0].unsafeAddr, address[i][1])
  echo(fmt"{deobfuscation(buff, address[i][1])}","\n")